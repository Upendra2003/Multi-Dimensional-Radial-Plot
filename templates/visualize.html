<!DOCTYPE html>
<html>
  <head>
    <title>5D Radial Wheel Plot</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <link rel="stylesheet" href="static/style.css" />
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h2>5D Data Visualized as Radial Wheel in 3D</h2>
        <p>
          Interactive visualization of high-dimensional data using radial
          projection
        </p>
      </div>

      <div class="controls">
        <div class="control-group">
          <label for="colorMode">Color Mode:</label>
          <select id="colorMode">
            <option value="tier">By Price Tier</option>
            <option value="gradient">Gradient Scale</option>
            <option value="feature">By Feature</option>
          </select>
        </div>
        <div class="control-group">
          <label for="viewMode">View Mode:</label>
          <select id="viewMode">
            <option value="standard">Standard</option>
            <option value="top">Top View</option>
            <option value="side">Side View</option>
          </select>
        </div>
        <div class="control-group">
          <button id="rotateBtn">‚è∏Ô∏è Pause Rotation</button>
        </div>
        <div class="control-group">
          <button id="resetBtn">üîÑ Reset View</button>
        </div>
        <div class="control-group">
          <button id="fullscreenBtn">üîç Fullscreen</button>
        </div>
      </div>

      <div id="plot">
        <div class="loading">Loading visualization...</div>
      </div>

      <div class="info-panel">
        <div class="info-card">
          <h3>üéØ Visualization Status</h3>
          <p>
            <span
              class="status-indicator status-rotating"
              id="rotationStatus"
            ></span>
            <span id="rotationText">Auto-rotating (pauses on hover)</span>
          </p>
          <div class="stats-grid">
            <div class="stat-item">
              <div class="stat-value" id="pointCount">0</div>
              <div class="stat-label">Data Points</div>
            </div>
            <div class="stat-item">
              <div class="stat-value" id="featureCount">0</div>
              <div class="stat-label">Features</div>
            </div>
          </div>
        </div>

        <div class="info-card">
          <h3>üé® Color Legend</h3>
          <p>Data points are colored by price tier:</p>
          <div class="legend-items">
            <div class="legend-item">
              <div class="legend-dot" style="background: #28a745"></div>
              <span>Low (< 40%)</span>
            </div>
            <div class="legend-item">
              <div class="legend-dot" style="background: #fd7e14"></div>
              <span>Mid (40-70%)</span>
            </div>
            <div class="legend-item">
              <div class="legend-dot" style="background: #dc3545"></div>
              <span>High (> 70%)</span>
            </div>
          </div>
        </div>

        <div class="info-card">
          <h3>üéÆ Interactions</h3>
          <ul style="list-style: none; padding: 0">
            <li>
              üñ±Ô∏è <strong>Rotate:</strong> Click and drag to rotate the view
            </li>
            <li>üîç <strong>Zoom:</strong> Scroll to zoom in/out</li>
            <li>
              üìä <strong>Hover:</strong> See detailed values for each point
            </li>
            <li>
              ‚è∏Ô∏è <strong>Auto-pause:</strong> Rotation pauses when hovering
            </li>
            <li>
              üéõÔ∏è <strong>Controls:</strong> Use buttons to change view modes
            </li>
          </ul>
        </div>

        <div class="info-card">
          <h3>üìä How It Works</h3>
          <p>
            Each feature is assigned a direction (spoke) in a circular plane.
            Data points are projected onto these spokes based on normalized
            values, with the output forming the height (Y-axis).
          </p>
          <p>
            <strong>Formula:</strong> x = Œ£(feature √ó cos(angle)), z = Œ£(feature
            √ó sin(angle)), y = output
          </p>
        </div>
      </div>
    </div>

    <script>
      class EnhancedRadialWheel {
        constructor() {
          this.rotating = true;
          this.angle = 0;
          this.animationFrame = null;
          this.plotData = null;
          this.currentColorMode = "tier";
          this.init();
        }

        init() {
          this.setupEventListeners();
          this.loadData();
        }

        setupEventListeners() {
          document.getElementById("rotateBtn").addEventListener("click", () => {
            this.toggleRotation();
          });

          document.getElementById("resetBtn").addEventListener("click", () => {
            this.resetView();
          });

          document
            .getElementById("fullscreenBtn")
            .addEventListener("click", () => {
              this.toggleFullscreen();
            });

          document
            .getElementById("colorMode")
            .addEventListener("change", (e) => {
              this.currentColorMode = e.target.value;
              this.updateVisualization();
            });

          document
            .getElementById("viewMode")
            .addEventListener("change", (e) => {
              this.changeViewMode(e.target.value);
            });
        }

        loadData() {
          fetch("/api/points")
            .then((response) => response.json())
            .then((data) => {
              this.plotData = data;
              this.createVisualization(data);
              this.updateStats(data);
            })
            .catch((error) => {
              console.error("Error loading data:", error);
              document.getElementById("plot").innerHTML =
                '<div class="loading">Error loading data. Please check your API endpoint.</div>';
            });
        }

        createVisualization(data) {
          const traces = [];

          // Enhanced color mapping
          const colorMaps = {
            tier: {
              low: "#28a745",
              mid: "#fd7e14",
              high: "#dc3545",
            },
            gradient: {
              low: "#4ecdc4",
              mid: "#45b7d1",
              high: "#6c5ce7",
            },
            feature: {
              low: "#a29bfe",
              mid: "#fd79a8",
              high: "#fdcb6e",
            },
          };

          const currentColors = colorMaps[this.currentColorMode];

          const getCluster = (y) => {
            if (y < 0.4) return "low";
            else if (y < 0.7) return "mid";
            else return "high";
          };

          // Enhanced data lines with improved tooltips
          data.lines.forEach((line, index) => {
            const x = [line[0][0], line[1][0]];
            const y = [line[0][1], line[1][1]];
            const z = [line[0][2], line[1][2]];
            const tier = getCluster(line[1][1]);

            traces.push({
              type: "scatter3d",
              mode: "lines+markers",
              x,
              y,
              z,
              line: {
                width: 3,
                color: currentColors[tier],
              },
              marker: {
                size: 4,
                color: currentColors[tier],
                opacity: 0.8,
              },
              name: `${tier.toUpperCase()} (${(line[1][1] * 100).toFixed(0)}%)`,
              text: [
                `Origin`,
                `Output: ${(line[1][1] * 100).toFixed(
                  1
                )}%<br>Tier: ${tier.toUpperCase()}<br>Coordinates: (${line[1][0].toFixed(
                  2
                )}, ${line[1][1].toFixed(2)}, ${line[1][2].toFixed(2)})`,
              ],
              hoverinfo: "text",
              opacity: 0.8,
              showlegend: index < 3,
              legendgroup: tier,
            });
          });

          // Enhanced feature spokes
          const n = data.labels.length;
          const radius = 1;
          const angles = [...Array(n).keys()].map((i) => (2 * Math.PI * i) / n);

          angles.forEach((angle, i) => {
            const x = [0, radius * Math.cos(angle)];
            const y = [0, 0];
            const z = [0, radius * Math.sin(angle)];

            traces.push({
              type: "scatter3d",
              mode: "lines+text",
              x,
              y,
              z,
              line: {
                width: 5,
                color: "rgba(255,255,255,0.8)",
                dash: "dash",
              },
              text: ["", data.labels[i]],
              textposition: "top right",
              textfont: {
                size: 14,
                color: "white",
                family: "Arial Black",
              },
              name: data.labels[i],
              showlegend: false,
              visible: true,
              hoverinfo: "text",
              hovertext: [
                ``,
                `Feature: ${data.labels[i]}<br>Angle: ${(
                  (angle * 180) /
                  Math.PI
                ).toFixed(1)}¬∞`,
              ],
            });
          });

          // Enhanced base circle
          const circle_x = angles
            .map((a) => radius * Math.cos(a))
            .concat(radius * Math.cos(angles[0]));
          const circle_y = angles.map(() => 0).concat(0);
          const circle_z = angles
            .map((a) => radius * Math.sin(a))
            .concat(radius * Math.sin(angles[0]));

          traces.push({
            type: "scatter3d",
            mode: "lines",
            x: circle_x,
            y: circle_y,
            z: circle_z,
            line: {
              color: "rgba(255,255,255,0.6)",
              width: 3,
              dash: "dot",
            },
            name: "Wheel Base",
            showlegend: false,
            hoverinfo: "skip",
          });

          // Enhanced layout
          const layout = {
            scene: {
              xaxis: {
                title: { text: "Radial X", font: { color: "white", size: 14 } },
                range: [-1.3, 1.3],
                showgrid: true,
                gridcolor: "rgba(255,255,255,0.2)",
                showbackground: false,
                tickfont: { color: "white" },
              },
              yaxis: {
                title: {
                  text: "Output (Y)",
                  font: { color: "white", size: 14 },
                },
                range: [-0.2, 1.2],
                showgrid: true,
                gridcolor: "rgba(255,255,255,0.2)",
                showbackground: false,
                tickfont: { color: "white" },
              },
              zaxis: {
                title: { text: "Radial Z", font: { color: "white", size: 14 } },
                range: [-1.3, 1.3],
                showgrid: true,
                gridcolor: "rgba(255,255,255,0.2)",
                showbackground: false,
                tickfont: { color: "white" },
              },
              camera: {
                eye: { x: 1.6, y: 1, z: 1.6 },
              },
              bgcolor: "rgba(0,0,0,0)",
            },
            margin: { l: 0, r: 0, b: 0, t: 0 },
            paper_bgcolor: "rgba(0,0,0,0)",
            plot_bgcolor: "rgba(0,0,0,0)",
            showlegend: true,
            legend: {
              font: { color: "white", size: 12 },
              bgcolor: "rgba(255,255,255,0.1)",
              bordercolor: "rgba(255,255,255,0.3)",
              borderwidth: 1,
            },
          };

          Plotly.newPlot("plot", traces, layout, {
            responsive: true,
            displayModeBar: true,
            modeBarButtonsToRemove: ["pan2d", "lasso2d"],
            displaylogo: false,
          }).then(() => {
            this.setupPlotInteractions();
            this.startRotation();
          });
        }

        setupPlotInteractions() {
          const plotElement = document.getElementById("plot");

          plotElement.onmouseenter = () => {
            if (this.rotating) {
              this.updateRotationStatus(false);
            }
          };

          plotElement.onmouseleave = () => {
            if (!this.rotating) {
              this.updateRotationStatus(true);
            }
          };
        }

        startRotation() {
          const animate = () => {
            if (this.rotating) {
              this.angle += 0.005;
              Plotly.relayout("plot", {
                "scene.camera.eye": {
                  x: 1.6 * Math.cos(this.angle),
                  y: 1,
                  z: 1.6 * Math.sin(this.angle),
                },
              });
            }
            this.animationFrame = requestAnimationFrame(animate);
          };
          animate();
        }

        toggleRotation() {
          this.rotating = !this.rotating;
          this.updateRotationStatus(this.rotating);
        }

        updateRotationStatus(isRotating) {
          this.rotating = isRotating;
          const statusIndicator = document.getElementById("rotationStatus");
          const statusText = document.getElementById("rotationText");
          const rotateBtn = document.getElementById("rotateBtn");

          if (isRotating) {
            statusIndicator.className = "status-indicator status-rotating";
            statusText.textContent = "Auto-rotating (pauses on hover)";
            rotateBtn.innerHTML = "‚è∏Ô∏è Pause Rotation";
          } else {
            statusIndicator.className = "status-indicator status-paused";
            statusText.textContent = "Rotation paused";
            rotateBtn.innerHTML = "‚ñ∂Ô∏è Start Rotation";
          }
        }

        resetView() {
          this.angle = 0;
          Plotly.relayout("plot", {
            "scene.camera.eye": { x: 1.6, y: 1, z: 1.6 },
          });
        }

        changeViewMode(mode) {
          const cameras = {
            standard: { x: 1.6, y: 1, z: 1.6 },
            top: { x: 0, y: 2.5, z: 0 },
            side: { x: 2.5, y: 0, z: 0 },
          };

          Plotly.relayout("plot", {
            "scene.camera.eye": cameras[mode],
          });
        }

        toggleFullscreen() {
          const plotElement = document.getElementById("plot");
          if (!document.fullscreenElement) {
            plotElement.requestFullscreen();
          } else {
            document.exitFullscreen();
          }
        }

        updateVisualization() {
          if (this.plotData) {
            this.createVisualization(this.plotData);
          }
        }

        updateStats(data) {
          document.getElementById("pointCount").textContent = data.lines.length;
          document.getElementById("featureCount").textContent =
            data.labels.length;
        }
      }

      // Initialize when DOM is loaded
      document.addEventListener("DOMContentLoaded", () => {
        new EnhancedRadialWheel();
      });
    </script>
  </body>
</html>
